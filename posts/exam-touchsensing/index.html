<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-07-18">

<title>Exam: Touch Sensing – Đinh Tiến Thắng</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Đinh Tiến Thắng</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Đinh Tiến Thắng</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Exam: Touch Sensing</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Exam</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">July 18, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#importance-of-touch-sensing" id="toc-importance-of-touch-sensing" class="nav-link active" data-scroll-target="#importance-of-touch-sensing">Importance of Touch Sensing</a>
  <ul class="collapse">
  <li><a href="#why-is-it-important" id="toc-why-is-it-important" class="nav-link" data-scroll-target="#why-is-it-important">Why is it important?</a></li>
  </ul></li>
  <li><a href="#human-touch-sensing" id="toc-human-touch-sensing" class="nav-link" data-scroll-target="#human-touch-sensing">Human Touch Sensing</a>
  <ul class="collapse">
  <li><a href="#mechanoreceptors" id="toc-mechanoreceptors" class="nav-link" data-scroll-target="#mechanoreceptors">Mechanoreceptors</a></li>
  <li><a href="#thermoreceptors-nocireceptors-pain-proprioreceptors-imu-chemoreceptors" id="toc-thermoreceptors-nocireceptors-pain-proprioreceptors-imu-chemoreceptors" class="nav-link" data-scroll-target="#thermoreceptors-nocireceptors-pain-proprioreceptors-imu-chemoreceptors">Thermoreceptors, Nocireceptors (pain), Proprioreceptors (IMU), Chemoreceptors</a></li>
  <li><a href="#difficult-to-reconstruct" id="toc-difficult-to-reconstruct" class="nav-link" data-scroll-target="#difficult-to-reconstruct">Difficult to reconstruct</a></li>
  </ul></li>
  <li><a href="#touch-sensing-hardware" id="toc-touch-sensing-hardware" class="nav-link" data-scroll-target="#touch-sensing-hardware">Touch Sensing Hardware</a>
  <ul class="collapse">
  <li><a href="#requirements" id="toc-requirements" class="nav-link" data-scroll-target="#requirements">Requirements</a></li>
  <li><a href="#technology" id="toc-technology" class="nav-link" data-scroll-target="#technology">Technology</a></li>
  </ul></li>
  <li><a href="#vbts" id="toc-vbts" class="nav-link" data-scroll-target="#vbts">VBTS</a></li>
  <li><a href="#touch-simulation" id="toc-touch-simulation" class="nav-link" data-scroll-target="#touch-simulation">Touch Simulation</a></li>
  <li><a href="#perception-in-touch" id="toc-perception-in-touch" class="nav-link" data-scroll-target="#perception-in-touch">Perception in Touch</a>
  <ul class="collapse">
  <li><a href="#depth-estimation-3d-reconstruction" id="toc-depth-estimation-3d-reconstruction" class="nav-link" data-scroll-target="#depth-estimation-3d-reconstruction">Depth Estimation &amp; 3D Reconstruction</a></li>
  <li><a href="#image-to-video" id="toc-image-to-video" class="nav-link" data-scroll-target="#image-to-video">Image to Video</a></li>
  <li><a href="#force-detection" id="toc-force-detection" class="nav-link" data-scroll-target="#force-detection">Force detection</a></li>
  <li><a href="#objectmaterial-classification" id="toc-objectmaterial-classification" class="nav-link" data-scroll-target="#objectmaterial-classification">Object/Material Classification</a></li>
  <li><a href="#object-property-regression" id="toc-object-property-regression" class="nav-link" data-scroll-target="#object-property-regression">Object property regression</a></li>
  <li><a href="#slip-detection" id="toc-slip-detection" class="nav-link" data-scroll-target="#slip-detection">Slip detection</a></li>
  <li><a href="#pose-estimation-prediction" id="toc-pose-estimation-prediction" class="nav-link" data-scroll-target="#pose-estimation-prediction">Pose Estimation &amp; Prediction</a></li>
  <li><a href="#multi-modal-transfer" id="toc-multi-modal-transfer" class="nav-link" data-scroll-target="#multi-modal-transfer">Multi-modal Transfer</a></li>
  </ul></li>
  <li><a href="#control-using-touch" id="toc-control-using-touch" class="nav-link" data-scroll-target="#control-using-touch">Control using Touch</a>
  <ul class="collapse">
  <li><a href="#grasping" id="toc-grasping" class="nav-link" data-scroll-target="#grasping">Grasping</a></li>
  <li><a href="#manipulation" id="toc-manipulation" class="nav-link" data-scroll-target="#manipulation">Manipulation</a></li>
  <li><a href="#locomotion" id="toc-locomotion" class="nav-link" data-scroll-target="#locomotion">Locomotion</a></li>
  </ul></li>
  <li><a href="#why-is-touch-an-important-sense" id="toc-why-is-touch-an-important-sense" class="nav-link" data-scroll-target="#why-is-touch-an-important-sense">Why is touch an important sense?</a></li>
  <li><a href="#explain-3-hardware-technologies-except-vision-based-for-sensing-touch." id="toc-explain-3-hardware-technologies-except-vision-based-for-sensing-touch." class="nav-link" data-scroll-target="#explain-3-hardware-technologies-except-vision-based-for-sensing-touch.">Explain 3 hardware technologies (except vision-based) for sensing touch.</a></li>
  <li><a href="#how-do-vision-based-tactile-sensors-work" id="toc-how-do-vision-based-tactile-sensors-work" class="nav-link" data-scroll-target="#how-do-vision-based-tactile-sensors-work">How do Vision-based Tactile Sensors work?</a></li>
  <li><a href="#why-is-simulating-touch-hard" id="toc-why-is-simulating-touch-hard" class="nav-link" data-scroll-target="#why-is-simulating-touch-hard">Why is simulating touch hard?</a></li>
  <li><a href="#what-forces-can-markers-detect" id="toc-what-forces-can-markers-detect" class="nav-link" data-scroll-target="#what-forces-can-markers-detect">What forces can markers detect?</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="importance-of-touch-sensing" class="level1">
<h1>Importance of Touch Sensing</h1>
<section id="why-is-it-important" class="level2">
<h2 class="anchored" data-anchor-id="why-is-it-important">Why is it important?</h2>
<p><strong>Human</strong> to feel the emotion &amp; grasp objects</p>
<p><strong>Robotics</strong>complement sensor at local scale e.g:</p>
<ul>
<li>precise direct local scale force+position+direction: grasping needs a sense of a correct force and direction applying on an object, too soft, will slip, too strong and not correct direction will also apply forces wrongly =&gt; also slip. Soley relying on visual might not be able to detect that because just 1-2 pixels.</li>
<li>avoid vision occlusion and noise: in dark environment, human rely on touching surrounding things in room</li>
</ul>
<p>=&gt; actually not widely yet because we havent had much proofs and experiment to demonstrate its proficiency but some works have been done. e.g:</p>
<ul>
<li>The Feeling of Success 2017: complement 2 RGB-D cameras by 2 GelSight sensors -&gt; get object position from RGB-D, labels based on success lift or not-&gt; 83% success, only-vision only 56%</li>
<li>General In-hand Rotation with Vision and Touch 2023: rotation reward X,Y,Z</li>
</ul>
</section>
</section>
<section id="human-touch-sensing" class="level1">
<h1>Human Touch Sensing</h1>
<section id="mechanoreceptors" class="level2">
<h2 class="anchored" data-anchor-id="mechanoreceptors">Mechanoreceptors</h2>
<p>force, position, pressure, vibration, stretch. Everything is in <strong>Dermis</strong>, but <strong>Epidermis</strong> is outer layer to protect, re-generating and healing:</p>
<ul>
<li>Merkel’s disk: skin upper layer, slowly adapting (at presence of static stimulus), balance structure =&gt; good for shape+texture identification &amp; light touch</li>
<li>Meissner’s corpuscle: also upper layer, but rapid adapting (at stimulus change, gradient of touch), vertical structure =&gt; good for pressure sensing + low frequency</li>
<li>Pacinian corpuscle: deep in skin layer, and also rapid adapting, BUT the round shape =&gt; high frequency sensing</li>
<li>Ruffini Endings: deep in skin layer, slow adapting, vertical structure =&gt; good for stretch detection</li>
</ul>
</section>
<section id="thermoreceptors-nocireceptors-pain-proprioreceptors-imu-chemoreceptors" class="level2">
<h2 class="anchored" data-anchor-id="thermoreceptors-nocireceptors-pain-proprioreceptors-imu-chemoreceptors">Thermoreceptors, Nocireceptors (pain), Proprioreceptors (IMU), Chemoreceptors</h2>
</section>
<section id="difficult-to-reconstruct" class="level2">
<h2 class="anchored" data-anchor-id="difficult-to-reconstruct">Difficult to reconstruct</h2>
<p>Spatial Resolution + Normal Force Resolution currently human finger finer</p>
</section>
</section>
<section id="touch-sensing-hardware" class="level1">
<h1>Touch Sensing Hardware</h1>
<section id="requirements" class="level2">
<h2 class="anchored" data-anchor-id="requirements">Requirements</h2>
<ul>
<li>small =&gt; more challenging grasping tasks like surgery</li>
<li>reliability =&gt; precise &amp; robust</li>
<li>manufacture &amp; affordable =&gt; more approachable for research and use</li>
</ul>
</section>
<section id="technology" class="level2">
<h2 class="anchored" data-anchor-id="technology">Technology</h2>
<ul>
<li><strong>Capacitive:</strong> touch represent a parallel capacitor to ground (multiple touch possible), but in many cases this would be wrongly intepreted (e.g: any conductive material noise but without any force like water)</li>
<li><strong>Ressistive:</strong> material bend create change in resistance R = ro * l / S =&gt; widely used, cheap, insensitive to liquid, but no multi-touch</li>
<li><strong>Piezoelectric</strong> generates electrical field at mechanical change because of breaking out balance state of + &amp; - ions =&gt; electric movements =&gt; good for vibration</li>
<li><strong>Magnetic</strong> interparticle position changes =&gt; changes in magnetic field</li>
</ul>
</section>
</section>
<section id="vbts" class="level1">
<h1>VBTS</h1>
<ul>
<li><p>Advantage 1: high spatial resolution &amp; feature, utilizing well-studied techniques to analyze &amp; process data captured</p></li>
<li><p>Challenge 1: unifying VBTS:</p>
<ul>
<li>currently no set of uniform sensor configuration, each sensor has different outcome (GelSight, DIGIT, change Elastomer) =&gt; cannot compare or benchmark</li>
<li>each situation needs different form factor (flat, curved) =&gt; so difficult to unify</li>
</ul></li>
<li><p>Challenge 2: Robust high precision &amp; complexity at small size:</p>
<ul>
<li>electronics problem about heat, computation limit, bandwidth, latency, …</li>
<li>Camera &amp; optical system has to be very durable &amp; precise</li>
</ul></li>
<li><p>Challenge 3: Slow temporal resolution. No vibration bc of elastomer damping and camera framerate</p></li>
<li><p>Design factors:</p>
<ul>
<li>Elastomer for recognizing touch features (it has a durability problem that it will wear out after sometimes so needs re-calibrate or change, because it cannot re-generate like human skin)</li>
<li>Lighting needs correct calibration depending on position, because it can create shadows</li>
<li>Camera &amp; optical system has to be very high resolution</li>
</ul></li>
</ul>
</section>
<section id="touch-simulation" class="level1">
<h1>Touch Simulation</h1>
<ul>
<li><strong>Purpose</strong> quickly generate a lot of data for analyse and processing, and a rough study of behavior in real world before really working on expensive real model</li>
<li><strong>Multi-Body Dynamics Modelling</strong>
<ul>
<li>well studied</li>
<li>but high computation cost on complex environment</li>
</ul></li>
</ul>
</section>
<section id="perception-in-touch" class="level1">
<h1>Perception in Touch</h1>
<p>mostly start by using Markers. It is simple but good, we can track the position by time easily. The only designing factor is to calibrate the initial marker distortion. Because the camera see from a singular perspective.</p>
<section id="depth-estimation-3d-reconstruction" class="level2">
<h2 class="anchored" data-anchor-id="depth-estimation-3d-reconstruction">Depth Estimation &amp; 3D Reconstruction</h2>
<p>Color gradient (change in color by time) + Bend in markers</p>
</section>
<section id="image-to-video" class="level2">
<h2 class="anchored" data-anchor-id="image-to-video">Image to Video</h2>
<p>one image cannot do anything, mostly what we care is a change detection (force, slip) =&gt;</p>
<ul>
<li>RNN</li>
<li>Transformer</li>
<li>Optical Flow</li>
</ul>
</section>
<section id="force-detection" class="level2">
<h2 class="anchored" data-anchor-id="force-detection">Force detection</h2>
<ul>
<li>Touch detection was in exercise 3. input 2 digit images: =&gt; use simple ResNet or Vision Transformer:
<ul>
<li>many way to implement: either concatenate 2 images in the same input then feed into one network, but I was afraid the network has to learn differentiating 2 images separately, so I input each of them in separate CNN network, after that concatenate them into linear layers.</li>
</ul></li>
</ul>
</section>
<section id="objectmaterial-classification" class="level2">
<h2 class="anchored" data-anchor-id="objectmaterial-classification">Object/Material Classification</h2>
<ul>
<li>Coin: coin classification in the exercise 2, I used vision transformer for image</li>
<li>Hardness: LSTM, each timeframe a CNN, if the frame features involve with bolder change by time =&gt; it is harder</li>
</ul>
</section>
<section id="object-property-regression" class="level2">
<h2 class="anchored" data-anchor-id="object-property-regression">Object property regression</h2>
</section>
<section id="slip-detection" class="level2">
<h2 class="anchored" data-anchor-id="slip-detection">Slip detection</h2>
<ul>
<li>LSTM using 2 inputs at each frame (GelSight + external image), each frame and each input goes through a separate CNN</li>
</ul>
</section>
<section id="pose-estimation-prediction" class="level2">
<h2 class="anchored" data-anchor-id="pose-estimation-prediction">Pose Estimation &amp; Prediction</h2>
<ul>
<li>Tac2Pose: mkeypoint is feature matching of real tactile image with the closest simulated data collected, this kinda needs to know the objece model in advance</li>
<li>Slip Prediction: seems to not yet well-studied</li>
</ul>
</section>
<section id="multi-modal-transfer" class="level2">
<h2 class="anchored" data-anchor-id="multi-modal-transfer">Multi-modal Transfer</h2>
<ul>
<li>Goal: use of multiple sensor:</li>
<li>Method: learning based, inputs are e.g.&nbsp;GelSight, external iamge and go through CNN layers separately, then concatenate them in the same linear laers, output is just a classification of are they the same 1 or 0 (sigmoid cross entropy loss)</li>
<li>this is important so that in future we can utilize them in more complex system utilizing multiple sensor:
<ul>
<li>across sensors: DIGIT, GelSight,…</li>
<li>across tasks</li>
</ul></li>
</ul>
</section>
</section>
<section id="control-using-touch" class="level1">
<h1>Control using Touch</h1>
<section id="grasping" class="level2">
<h2 class="anchored" data-anchor-id="grasping">Grasping</h2>
<ul>
<li>The Feeling of Success 2017: input GelSight + external camera</li>
<li>More than a Feeling 2018 add temporal aspect + action input (at each timestep predicts the next timestep success rate), it is also where you figured out that applying more force does not always means better</li>
</ul>
</section>
<section id="manipulation" class="level2">
<h2 class="anchored" data-anchor-id="manipulation">Manipulation</h2>
<ul>
<li>DIGIT 2020: MBRL similar to Dreamer, from my unterstanding only goal at one of 2 sensors</li>
<li>General In-Hand Rotation 2023:</li>
<li>Learning to play Piano with touch 2022: MIDI converter+tactilesensing+proprioperceptive sensor RL</li>
</ul>
</section>
<section id="locomotion" class="level2">
<h2 class="anchored" data-anchor-id="locomotion">Locomotion</h2>
<ul>
<li>provide information about force &amp; contact, but not so many works</li>
</ul>
</section>
</section>
<section id="why-is-touch-an-important-sense" class="level1">
<h1>Why is touch an important sense?</h1>
<ul>
<li>Which parameters can it detect? (Contact Position, Intensity) # Which touch receptors has a human?</li>
<li>What do Proprioceptors detect? (Touch Position)</li>
<li>Which Mechanoreceptors do exist and what do they detect?</li>
</ul>
</section>
<section id="explain-3-hardware-technologies-except-vision-based-for-sensing-touch." class="level1">
<h1>Explain 3 hardware technologies (except vision-based) for sensing touch.</h1>
<ul>
<li>How do they work (basic principle)?</li>
<li>Advantages/Disadvantages?</li>
</ul>
</section>
<section id="how-do-vision-based-tactile-sensors-work" class="level1">
<h1>How do Vision-based Tactile Sensors work?</h1>
<ul>
<li>Mention the three components: Elastomer, LEDs, Camera; Explain their relation
<ul>
<li>Advantages compared to classical hardware methods? (Modularity, high resolution, …)</li>
<li>Spatial Resolution? (Better than human skin, refer to the diagram of the lecture)</li>
<li>Temporal Resolution? (Not good, high bandwidth diminishes framerate -&gt; effectively no vibration detectable)</li>
</ul></li>
</ul>
</section>
<section id="why-is-simulating-touch-hard" class="level1">
<h1>Why is simulating touch hard?</h1>
<ul>
<li>(Soft Body Physics)</li>
</ul>
</section>
<section id="what-forces-can-markers-detect" class="level1">
<h1>What forces can markers detect?</h1>
<ul>
<li>(Shear Forces)
<ul>
<li>How is a marker-based flow field created? (Mention frame-to-frame tracking to create vectors)</li>
</ul></li>
<li>Why is Touch important in humans and robotics?</li>
<li>What are differences between Touch and Vision? What information can we get from Touch which we cannot get from Vision?</li>
<li>What are the different receptors of the skin?</li>
<li>What are the different cells/corpuscles of mechanorecptors? What are they used for?</li>
<li>What are advantages and disadvantages of VBTS?</li>
<li>What kind of models in ML can be used to process images from VBTS? (CNN + LSTM, 3D CNN, Transformers) What are disadvantages of the 3D CNN approach?</li>
</ul>



</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/tienthangdinh\.github\.io\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>