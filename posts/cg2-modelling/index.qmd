---
title: "Advanced Modelling"
date: 2025-08-08
categories: [Computer Graphics, Advanced Modelling]
format:
  html:
    toc: true
    code-fold: true
    math: mathjax
---
# Implicit Surface
1. **Define the term implicit surface and explain the idea with a sketch!**
- f: R¬≥ ‚Üí R: f(x, y, z) = 0 
- The Interior: f(x) < 0.
- The Surface: f(x) = 0. 
- The Exterior: f(x) > 0.
- They use the following operations: levelset, CSG, 

2. **What is a regular implicit function and what does the implicit function theorem say about them?**
- Regular Implicit Function: An implicit function f is called regular if its gradient ‚àáf(x) does not vanish aka = 0 (no cut itself)
- Implicit Function Theorem:  if f is a regular function, then the implicit surface S(f) is a manifold. 

3. **How can one compute the surface normal of an implicit surface?**
- The gradient vector ‚àáf(x) is always orthogonal to the surface at x: n(x) ‚àù ‚àáf(x)

4. **Explain the advantage of an analytic computation of the gradient of an implicit function!**
- Accuracy: no numeric approximatation
- Fast: no need numeric apprixmiation

5. **Compare levelset surfaces with implicit surfaces!**
- Start with implicit surface  S(f) = {x | f(x) = 0}.
- A level set is an entire family of this function: l_Œª(x) = f(x) - Œª 

6. **How can CSG-operations be expressed in the formalism of implicit functions?**
- CSG on implicit functions (f‚ÇÅ, f‚ÇÇ, etc.), think like what would a position value be:
- f_union(x) = min(f‚ÇÅ(x), f‚ÇÇ(x)).
- f_intersection(x) = max(f‚ÇÅ(x), f‚ÇÇ(x)).
- Difference (A \ B): The set of points in A but not in B. This corresponds to f_difference(x) = max(f‚ÇÅ(x), -f‚ÇÇ(x)).

7. **Name examples of implicit surface primitives!**
- Implicit surface primitives can be defined in several ways:
    - SDF that we all know  (can utilize mixed Minkowski) (sphere f(x) = sqrt(x¬≤ + y¬≤ + z¬≤) - r)
    - Algebraic Surfaces: e.g. Quadrics (e.g., spheres, cylinders, cones) are algebraic surfaces of degree two. (sphere f(x) = x¬≤ + y¬≤ + z¬≤ - r¬≤)
    - Radial Basis Functions: Used to define "meta-balls" or "blobs" where a radially symmetric potential field is centered on a set of points.
    - Lattice Basis: Using a spline basis over a grid to define the implicit function.

8. **Given an image of a superquadric estimate the exponents ùëù‚ÇÅ and ùëù‚ÇÇ of the used Minkowski norms!**
- Exponent p‚ÇÅ controls the shape in the xy-plane (looking down the z-axis).
    - p‚ÇÅ < 2: The shape is concave or "star-like".
    - p‚ÇÅ = 2: The cross-section is a perfect circle.
    - p‚ÇÅ > 2: The cross-section becomes more "square-like".
- Exponent p‚ÇÇ controls the shape in the rz-plane (the profile along the z-axis).
    - p‚ÇÇ < 2: The shape is pointy at the poles.
    - p‚ÇÇ = 2: The profile is circular.
    - p‚ÇÇ > 2: The profile becomes more "box-like".

9. **Name same example shapes that can be represented by a quadratic implicit surface and precisely specify implicit functions for sphere and cylinder!**
- Sphere/Ellipsoid (centered at origin): f(x, y, z) = x¬≤ + y¬≤ + z¬≤ - 1 = 0
- Cylinder (aligned with z-axis): f(x, y, z) = x¬≤ + y¬≤ - 1 = 0

10. **Explain the principle of meta balls (Gaussian Splatting?)!**
- Meta balls (or blobs) are an implicit modeling technique used to create organic, smoothly blended shapes. The principle is:
- A set of "atoms" (center points c_i) are defined in space.
- Each atom generates a potential field function h_i(x) that decreases with distance from the atom's center (e.g., a Gaussian function exp(-||x - c_i||¬≤ / r_i¬≤)).
- The overall implicit function f(x) is defined by summing the potentials from all atoms and subtracting this sum from a flipped  Gaussian value: f(x) = 1/e - Œ£ h_i(x) (look at that function in the slide you will understand)
- The resulting implicit surface f(x) = 0 is a smooth surface that naturally blends together where the potential fields of different atoms overlap.

11. **Explain the Marching Cubes algorithm!**
- Goal: extracts a polygonal mesh (tessellates) an implicit surface defined on a grid. The steps are:
- For each voxel, evaluate the implicit function f at its 8 corners.
- Classify each corner as being inside (f < 0) or outside (f > 0). This creates an 8-bit index for the voxel (one bit per corner).
- lookup edges connecting interior with exterior using that 8bit
- For each intersected edge, calculate the precise intersection point (the "zero crossing").
- Connect it

12. **What problems arise at sharp creases and corners when using Marching Cubes?**
- cannot reproduce sharp creases or corners

13. **How can one reconstruct sharp creases and corners with the Dual Contouring approach?**
- **Idea**: placing additionally single representative vertex inside each grid cell that is intersected by the surface, rather than on the edges the whole time.
- For every grid edge that has a sign change, find the zero-crossing point and the surface normal (gradient) at that point. These define a tangent plane.
- Find the optimal point p that best fits all the tangent planes using Quadric Error Metric (QEM).

14. **Compare Space Warping and Function Value Mapping for the manipulation of implicit surfaces!**
- Function Value Mapping: combining the scalar values from generic functions: m^F(p) = m(f‚ÇÅ(p), f‚ÇÇ(p), ...):
    - CSG: Union (min), Intersection (max), Difference (max(f‚ÇÅ, -f‚ÇÇ)).
    - Levelset Mapping: m(f, Œª) = f - Œª
    - Outline Mapping: m(f, Œª) = f¬≤ - Œª¬≤ (creates two offset surfaces).
    - Blending: Smooth approximations of min and max for CSG union and intersection.
    - Adding Noise: m(f) = f + noise()
- Space Warping: These deform the surface by modifying the space (input coordinate)s before they are evaluated by the function f. The new function is f'(q) = f(w(q)), where w is the inverse warp.
    - Linear Transformations: Affine transformations like rotation, scaling, and shear, represented by a matrix M. The warp is w(q) = M‚Åª¬πq.
    - Taper: A non-uniform scaling along an axis.
    - Twist: A rotation around an axis where the angle of rotation depends on the position along that axis.
    - Bend: Deforming an object along a circular arc.

15. **Explain how to transform an implicit surface with an affine transformation! How can one compute the gradient of the transformed implicit surface?**
- To transform an implicit surface f(p) = 0 with an affine transformation to q = M*p:
- Find the inverse p = w(q) = M‚Åª¬πq. (bringing the coordinate system there)
- Then apply the original function: f^w(q) = f(w(q)) = f(M‚Åª¬πq)
- The gradient of the transformed surface is found using the chain rule: ‚àáf^w = ‚àáf(p) ‚ãÖ J_w
where ‚àáf(p) is the gradient of the original function evaluated at the un-warped point p, and J_w is the Jacobian of the warp function. For a linear transformation, the Jacobian is simply the matrix itself, so:
‚àáf^w(q) = ‚àáf(M‚Åª¬πq) ‚ãÖ M‚Åª¬π

16. **Given an image of a space warped implicit surface, argue whether it was generated via a Tapper, Twist or Bend transformation!**
we know

17. **Explain modified union and intersection operations that smoothly blend between implicit surfaces!**
- CSG union (min) putting a sphere at outside (1, 1). => (1-f1)^2 + (1-f2)^2
- CSG intersection (max) putting a sphere inside (-1, -1)
18. **How can one define the extent of the smoothing area?**
- aka the blending radius, can be controlled independently for each surface. Normalizing d_i = f_i / r_i

19. **What problems arise in areas where the implicit surfaces coincide? How can one conquer these problems?**
- when 2 blended surfaces become parallel or nearly parallel, unwanted bulging artifacts can occur where the blending influences undesirably accumulate. Idea: control when parallel => no blending, but when 90 deg. => max blending:
d_i ‚Üí d_i / (1 - |cos Œ∏|)

20. **Skeleton based with hard Implicit Surface**
- Given a point p: find the dot product between AB, and AP to get the projection (clamp between 0, 1)
- Get the height from that projection 
- Minus 1 (to make the surface to 1)

20. **How to do similar thing using Convolution?**
- An implicit surface generated from a skeleton (a geometric primitive like a point, line, or polygon) and a potential function (or filter kernel, h). 
- Implementation: skeleton function g (which is 1 on the skeleton and 0 elsewhere) convoluted by the potential function h. The final implicit surface is a level set of this resulting scalar field: f(r) = const - (g * h)(r) = 0.

21. **Compare distance surfaces and convolution surfaces!**
- Distance Surfaces: easy to implement but sharp
- Convolution Surfaces: smooth (can produce bulging) but more computationally complex

22. **How can one evaluate a convolution surface defined over a set of primitives?** 
- summing the result of each primitive skeleton

23. **Which filter kernels do you know and over which can these be integrated analytically?**
- Gaussian
- Cauchy
- Inverse powers of radius (radial basis)

24. **Do bulging artefacts also arise for convolution surfaces and if so, how can they be cured?**
- Solution:
    - Thick Skeletons: skeleton width thicker than the kernel radius
    - Weighted Skeletons: Use weights that decrease at the intersections of skeleton primitives

# 3D Scanning

1. **Name some techniques to acquire the shape of 3D objects!**
- Structured light (RGBD)
- stereo acquisition RGBD
- Tomographic reconstruction from X-ray images (CT scan).
- Time-of-flight
- Magnetic Resonance Tomography (MRI).

2. **Explain the idea of a structured light scanner!**
- known structured pattern of light is projected (e.g., vertical stripes) onto the 3D object.
- The projected pattern appears distorted in the image due to the object's surface shape.
- Because the system is calibrated, for any pixel in the camera image, we can determine which stripe
- triangulation.

3. **What is a homography?**
- transformation 3x3 homogeneous matrix H maps points from one 2D plane to another

4. **How many feature correspondences are needed to estimate a homography?**
- 3x3 matrix has 9 parameters but only 8 variables needed, the last one set to 1 (doesnt matter, scalable).
- Since each point-to-point correspondence provides 2 linear equations (x, y), needs 4 corresponding pairs
- calculate using SVD

5. **Under which situations can two images be brought into correspondence with a homography?**
- Planar Scene: The images are of a 3D scene where all the points of interest lie on a single plane (like a checkerboard). The camera can undergo any rotation and translation.
- Pure Rotation: The camera only rotates around its optical center (pinhole) and does not translate. In this case, the 3D scene can have any arbitrary shape.

6. **CALIBRATION: What are the intrinsic and extrinsic camera parameters in the pinhole camera model?**
- Extrinsic Parameters: camera's position and orientation relative to the world coordinate system. 
- Intrinsic Parameters: focal lengths in pixel units (sx, sy), the principal point (the pixel coordinates where the optical axis intersects the image plane) (cx, cy), and a skew parameter (h).

7. **How many degrees of freedom do we have for the intrinsic and extrinsic parameters?**
- Extrinsic Parameters: 3 for rotation and 3 for translation, for a total of 6 degrees of freedom.
- Intrinsic Parameters: 2 focal length at diagonal (scaling) + 2 principle point (translation) + 1 skew matrix (shear) = 5 (sx, sy, cx, cy, h).

8. **Why is the pinhole model in practice not sufficient and how can it be extended?**
- non-linear distortion (if you show me formula i can explain)

9. **Explain the procedure for camera calibration according to Zhang!**
Zhang's method is a widely used camera calibration technique:
- Acquire 3 images from different orientations.
- Detect multiples anker points of the image (mostly corners)
- for each new image -> a new homography H!!! nice!!! (hollistic intrinsic K + extrinsic [R|t])
- 2 equations each image, and utilizing $H = K * [R|t]$:
  1.  **R are orthogonal  => dot products** => creating inverse K  $r_1r_2 = h_1^TK^{-T}K^{-1}h_2$
  2.  **R should have same size everywhere** => $h_1^TK^{-T}K^{-1}h1 = h2^TK^{-T}K^{-1}h2$
- 3 images * 2 equations each images we have 6 equation to find $K$ (in slides is B)
- add more non-linear distortion if needed


10.  **How many shots of the calibration plate are needed at least? Why?**
- 5 linear intrinsic parameter (ffcch)
- A minimum of 3 images are needed. each image = 1 homography = 2 linear constraints  inintrinsic parameters derived. 
- => 3 views (providing 6 constraints) are required to solve the system of equations.

11. **Why are the parameters of the camera model estimated in two steps?**
- Linear Estimation: first step ignores distortion => initial point
- Non-linear Refinement: include distortion using algorithm to solve

12. **What is the typical procedure to calibrate a camera?**
- like said above (2 big steps linear for intrinsic) => nonlinear for distortion

13. **Explain a method to calibrate a camera-projector setup!**
- "inverse progress":
- Calibrate the camera first using a standard method.
- To establish correspondences for the projector, project gray-codes that encode the projector's pixel columns and rows onto a calibration plane
- The calibrated camera captures images of these patterns. This allows you to determine for each camera pixel which projector pixel is illuminating that spot.
- By detecting the checkerboard corners in the camera image, you can find their corresponding projector coordinates.
- Now that you have correspondences between known 3D world points (the checkerboard corners) and 2D projector image points, you can calibrate the projector using the same technique as for a camera.

14. **Explain the term Triangulation in the domain of structured light scanning!**
- stereo trigonometry

15. **What difficulty does one face with a non-linear camera-projector model for triangulation when working with stripe patterns? How can the problem be circumvented?**
- projector has distortion -> also inversely distort projector pattern

16. **Explain advantages of a 2-camera structured light scanning setup!**
Adding additional camera to a standard camera-projector setup provides several advantages:
- Reduces highlight problems: Specular reflections that might blind one camera can be correctly captured by the other.
- Increases surface visibility: It helps resolve occlusions, as a surface part hidden from one camera may be visible to the other.
- Increases precision: It provides multiple measurements of the same surface point, leading to a more robust and accurate reconstruction.

17. **Discuss the scanning of dynamic 3D scenes with structured light approaches!**
- High-speed systems: Use a synchronized high-speed camera and projector to capture the entire pattern sequence before the object moves significantly.
- Debrujin, GrayCode

18. **Explain and compare Line-Shift, Intensity Coding, Gray-Code and phase shift based structured light scanning!**
- Line-Shift: Projects one vertical line at a time => not good, because only 1 line => many shots
- Intensity Coding: 2 images: x = L2/L1
- Gray-Code: n images, see how a point change after n images (dark/white)
- Phase Shift: 3 images, see how a point change after 3 images (using continuos function )

19. **Why is the Gray-Code better suited for structured light 3D scanning?**
- avoid color bleeding (small scattered cells)

20. **How can one use de Bruijn Sequences to build a Single-Shot 3D Scanner?**
- idk

21. **Explain the basic idea for the separation of direct from indirect illumination! How can one make decoding of bit codes more robust with direct-indirect light separation?**
- Indirect: low frequency
- Direct_ high frequency

# 3D Processing

1. **Explain what the Riemannian-Graph is and how it can be used to filter outliers!**
- Riemannian-Graph: every point has outgoing edges connecting it to its k nearest neighbors.
- Outlier Filtering: This graph structure can be used to detect outliers. has outgoing but not incoming => no friends haha
- Extra (symetric Riemanian Graph, has something to do with Voronoi area, and the idea is only connect pointbetween the (similar) parallel voronoi poles)

2. **Describe a method to estimate the local sampling density of a point cloud!**
- area among 3-6 nearest neighbors

3. **Explain how to fit a least squares plane to a set of points! (also repeat details on that from CG1)**
- **Goal** find the plane $p=(n_x, n_y, n_z,d)$ that minimizes weighted sum displacement $f = p^TA^TWAp$
- Weight: Gaussian from center
- Weighted Covariance Matrix
- Find smallest eigenvalue
- similar to PCA but embed the tangental normal in => from max to min

4. **Is the least squares normal unique?**
No, can be n* or -n* => need orientation step.

5. **Motivate problems of the least squares fit in the vicinity of outliers, C‚Å∞ and C¬π discontinuities!**
- The standard L‚ÇÇ-norm (least squares) is highly sensitive discontiuinity C0 C2 + outliers
- => for example L1-norm is less sensitive

5. 1. **There is also the optimal weighting problem, but I dont remember**

6. **How to extend the weighted least squares normal fit to avoid smoothing out of normals in the vicinity of sharp corners and creases?**
- remember bilateral filtering? this one similar
- $w = w_1 w_{bilateral}$ where w1 is normal weight, w2 reduce the effect when tangent normal is different
- BUT to do this, we do not know the tangent normal, so just start with $w_{bilateral}=1$ first, then start using that to keep fitting

7. **How to compute a Minimum / Maximum Spanning Tree efficiently?**
- **Goal** a tree that go through all vertices but just through the edges with minimal costs

8. **Explain how to compute a consistent orientation of surface normals with the help of a Minimum Spanning Tree and explain variants of defining the edge costs?**
- Start with one or more normals that are known to be correctly oriented (e.g., from scanner position).
- Construct a neighbor graph (e.g., a Riemannian graph)
- Assign a cost (low for edges at smooth surface - high creases edges)
- Propagate through the MST. For each edge traversed, orient the neighbor's normal to be consistent with the current normal.
- flip criteria
  - Hoppe, Xie: if dot product $n_1 n_2 < 0$ then flip
  - K√∂nig: idea is simpler curve with less curvature

9. **Explain the ICP-algorithm!**
- **Start with BIGGEST ASSUMPTION:** oready initially coarse aligned. => alternates between 2 steps until convergence:
- Find closest Correspondences (like real physical closest - or normal matching - or even FPFH)
- Transform using minimal homography (similar to covariance matrix)
- SVD transformation for translation|rotation
- Nachteil: it really needs initially coarsely aligned, for example if 2 scans flipped, then it does not work

10. **What is normal-space sampling and how can it help to improve the ICP-algorithm?**
- **Goal** balance the set of normal vectors distributed from sampling => less biased to only flat plane fitting

11. **What possibilities do you know to define the distance measure used for the objective function of the registration optimization problem?**
- 2 main error metrics (distance measures) used in ICP:
- Point-to-Point Distance: simply minimize squared Euclidean distance between corresponding points
- Point-to-Plane Distance: minimizes the squared distance from a source point to the tangent plane at its corresponding target point (using dot product to project this chan duong cao)

12. **What variants do you know to extract corresponding point pairs for the ICP-algorithm?**
- Several matching strategies:
- Closest-Point: standard, but when they flip not good
- Normal Shooting: Project a point along its normal to find an intersection with the other surface
- Projection: Project a point from the source onto the target mesh **from the camera's point of view** (tbh honest i really do not know how this works)

13. **Explain and compare the surface reconstruction techniques silhouette-, space- and volume carving!**
- Silhouette Carving using only 2D RGB: create a 3D voxel space, project that 3D on binary silhouettte from every perspective image, start carving
- Space Carving using only 2D RGB: initialized silhouette carving + photo consistency over all images of that same voxel
- Volume Carving: space carving in RGBD. depth provides a much stronger initial constraint, nothing else to say, this is good!!!

14. **Given images of reconstructions, find out, which result was produced by silhouette-, space- or volume carving!**
- Silhouette Carving: results in convex looking
- Space Carving: actually convex but color constraint can reduce something, but not good enough
- Volume Carving: most accurate

15. **Explain how to use implicit functions for surface reconstruction! Why are constraints at the sample points not sufficient?**
- **Goal** Poisson uses 2 constraints:
- (‚àáœá ‚âà V) (V are the surface normals)
- (œá(p) = 0) constraints at surface (screened poisson)
- How to do this? we derivate one more to get the Laplace/Poisson equation where we seem to be able to to solve bc we know the divergence inside/outside (divœá = ‚àáV)
- then slowly make finer

# Rotation & Articulated Objects

1. **Explain 3 representations for rotations and discuss their suitability for interpolation between rotations!**
- 3x3 Rotation Matrices: Not suitable for direct interpolation. Linearly interpolating between two rotation matrices and re-normalizing does not produce a constant-velocity rotation and can result in unwanted scaling/shearing artifacts.
- Euler Angles: Simple to interpolate the three angles linearly, but this is highly problematic. It does not produce the "shortest path" rotation and is susceptible to gimbal lock
- Quaternions:Excellent for interpolation. 

2. **Discuss uniqueness of the different representations for rotations!**
- Rotation Matrices: 1 rotation 1 matrix eindeutig
- Euler Angles: (extrinsic & intrinsic)
- Axis-Angle / Quaternions: rotation by angle Œ± around axis n is identical to a rotation by angle -Œ± around axis -n. (q and -q) represent the exact same 3D rotation. (similar to complex number)

3. **What is a quaternion and how can it be used to rotate a vector around an axis?**
- is a 4-dimensional complex numbers, with one real part (s) and three imaginary parts (x, y, z). $(i¬≤=j¬≤=k¬≤=ijk=-1) \And (ijk)$ 
- To rotate p around $n=ai+bj+ck$ for $\alpha$ degree (where $a+b+c=1$ normalized):
- Represent p as a "pure" quaternion with a zero real part: $p_{quat} = (0, p)$.
The rotation is performed using the quaternion multiplication formula:
$p'_{quat} = (\cos(\frac{\alpha}{2}) + sin(\frac{\alpha}{2})(n)) * p_{quat} * (\cos(\frac{\alpha}{2}) - sin(\frac{\alpha}{2})(n))$
- Basically only rotate 3 dimension ijk out of 4 dimensions, therefore the inverse

4. **Which additional transformation can be expressed by the length of a quaternion?**
- unit quaternion (length = 1) -> pure rotation
- non-unit quaternion -> rotation + uniform scaling

5. **Given an image of a robot arm, explain the terms basis, node, joint and end effector!**
- we all know what those are

6. **Given images of joint types, classify joint type and enumerate degrees of freedom!**
- Revolute (1R): 1 DOF (1 rotation)
- Prismatic (1T): 1 DOF (1 translation)
- Universal (2R):2 DOF (2 revolute together)
- Spherical (3R): 3 DOF.
- Gimbal (3R): 3 DOF with Gimbal lock

7. **What is the difference between a kinematic chain and a kinematic tree?**
- Kinematic Chain: transofrmation base-> effector
- Kinematic Tree: bone hierarchy

8. **Discuss the difference between representing joint transformation as a sequence of rotation and translation compared to a sequence of translation and rotation!**
- ofcourse not the same => ( Denavit-Hartenberg) makes it deterministic

9. **Explain linearization of a kinematic tree for the efficient computation of world to joint transformations!**
- its a linear transformation: T(n+1) use Tn as base
- just calculate forward

10. **How many parameters are used in the Denavit-Hartenberg Convention to represent bone transformations in a kinematic chain?**
- 4 param, compared to Euler (2+3=6), Quaternion (7)
- d_i distance along z_i to meet common perpendicular length
- Œ±_i angular offset of the 2 joint axes z_i & z_i-1
- Œ∏_i actual angular change of x_i and x_i-1 on z-1 axe
- a_i common perpendicular length
- To sum up, DH = Rot(Œ∏_i) * Trans(d_i) * Trans(a_i) * Rot(Œ±_i), where the actual rotation is Rot(Œ∏_i) & Trans(d_i)
- EVENTUALLY then it can all be presented in a matrix in lecture but I do not remember, you can show me


11.  **Which joint types can be represented directly in the Denavit-Hartenberg Convention?**
- Revolute -> joint angle Œ∏_i is variable.
- Prismatic -> link offset d_i is variable.

12.  **How can other joint types be emulated in the Denavit-Hartenberg Convention?**
- combine them together with zero link offset

13.  **How can one compute the angles in the Denavite-Hartenberg Convention such that a full revolution of 360 degrees can be supported?**
- To support a full 360-degree => use arctan2(sine, cosine) => output (angle, quadrant).
- For an angle like the link twist Œ±_i, you compute both:
- sin(Œ±_i) = ||zÃÇ_{i-1} √ó zÃÇ_i||
- cos(Œ±_i) = <zÃÇ_{i-1}, zÃÇ_i>
- However, the sine term is always positive, restricting the angle to [0, œÄ]. SO that does not actually eliminate the result we want anyway => sign of the cross product of angle by taking a dot product dot producting with a third, orthogonal vector ( xÃÇ_i). 
- The final formula becomes: Œ±_i = sgn(<zÃÇ_{i-1} √ó zÃÇ_i, xÃÇ_i>) * arctan2(||zÃÇ_{i-1} √ó zÃÇ_i||, <zÃÇ_{i-1}, zÃÇ_i>)

# Skeleton Extraction
1. **Explain the term medial axis and be able to draw it into a 2D shape!**
- set of all interior points that have at least two closest points on the shape's boundary.
- A helpful analogy is the "grass-fire" model: imagine setting the entire boundary of the shape on fire simultaneously. The fire fronts would burn inwards at a constant speed. The medial axis is the set of points where the fire fronts meet and extinguish themselves.
- (For a 2D rectangle, the medial axis would look like an "H" shape turned on its side: a line segment down the center of the long axis, with two shorter line segments branching off perpendicularly towards the middle of the shorter sides.)

2. **Why is the medial axis not suitable as a curve skeleton of a 2D or a 3D shape?**
- Sensitivity to Noise: It is extremely sensitive to small perturbations or noise on the boundary. A tiny bump on the surface can create a new, often large, branch in the medial axis, making it unstable and overly complex.
- Dimensionality in 3D: For a 3D shape, the medial axis is not a 1D curve but a **2D surface**, which is not skeleton

3. **Name important properties of a curve skeleton!**
- 1D curve structure, even for 3D shapes.
- same topology as the shape (e.g., the same number of loops for holes/tunnels).
- lie in the center of the object's volume.
- invariant to isometric transformations (like bending) of the shape.
- Every point on the shape's surface should be "visible" from at least one point on the skeleton.
- insensitive to small amounts of noise

4. **Explain some techniques to compute a curve skeleton!**
- Erosion until 1D
- Distance Field: skeleton is maxima of this field.
- Voronoi: we all know
- General Field Functions: These methods use other types of vector or scalar fields, such as an electrostatic field, to find the central structure of the shape.


5. **Explain the competing front approach of Sharf et al. and name some advantages!**
- method for both surface reconstruction and skeleton extraction.
- Principle:
- An initial deformable mesh (a "front") is placed inside the point cloud.
- This front is inflated outwards, driven by a distance field, to reconstruct the shape.
- As the front expands, it may need to split to pass through narrow channels or merge when different parts of the front meet.
- **The skeleton is traced as the center of these evolving fronts.** Junctions in the skeleton are formed where fronts split or merge.
- Advantages:
- Robustness: It works well with noisy and incomplete data because it is driven by a global distance field and doesn't rely on local connectivity.
- Speed: The "on-the-fly" version is very fast and can compute a skeleton in seconds.
- Controllable Topology: The splitting and merging of fronts are controllable topological operations, leading to a well-defined skeleton.

# Rigging
1. **Explain the term rigging in the domain of character animation!**
- in animation:
- Rigging: building an internal skeleton and fitting it inside the 3D mesh.
- Skinning: binding the mesh's vertices to the bones of the skeleton.

2. **What are input and output to the Pinocchio automated rigging approach!**
Input: 3D mesh + skeleton
Output: embedded skeleton

3. **Give an overview of how the Skeleton is positioned inside the input polygonal mesh!**
- Discretization: The system first computes a medial axis approximation of the mesh and builds a graph from its sphere cover. This provides a discrete representation of the mesh's interior.
- Discrete Embedding: A coarse-to-fine optimization is performed. First, a simplified version of the skeleton is optimally placed within the graph using an A* search algorithm guided by a penalty function.
- Embedding Refinement: The full skeleton is then placed based on the coarse result, and its position is fine-tuned using a continuous gradient-descent optimization on a simplified penalty function.

4. **Name some terms of the energy function used to optimize the skeleton and explain how the authors adapted the energy function to a set of good and bad rigging examples!**
- The energy (penalty) function uses several weighted terms to guide the optimization. include:
- Center Distance: Penalizes bones for being far from the medial axis.
- Short Bones / Wrong Directions: Penalizes the skeleton for having bone lengths or orientations that differ significantly from the input skeleton's proportions.
- Feet: A specific term to ensure the feet are placed at the bottom of the model.
- Limb Sharing: Penalizes cases where multiple limbs are embedded into the same part of the mesh.
- supervised learning from bad & good examples
  
5. **Explain the idea of the RigMesh-Approach**
- integrate rigging into a sketch-based modeling workflow. Traditionally, rigging is a separate, final step performed after modeling is complete. If the model is changed, the rig must be redone. RigMesh makes the rigging process incremental. As a user draws and edits the shape of a character using sketches, the system automatically and continuously updates the internal skeleton and skinning weights => faster change

6. **Give some sources for mesh animations!**
A mesh animation (also called a vertex cache or point cache animation) is a sequence of meshes where the vertex positions change over time. Sources for this data include:
- Physics simulations (e.g., cloth or soft bodies).
- Motion capture data applied to a mesh.
- Keyframe animation created by an artist.

7. **How can one approximate a mesh animation with a skinned mesh representation?**
- The goal is to find a set of bones, bone transformations for each frame, and a set of vertex weights that, when applied to a single base mesh, best reproduces the entire input animation sequence. This is a decomposition problem. It seeks to compress the large amount of data from the mesh animation into a much more compact and controllable skinned mesh representation.

8. **Explain the principle steps of the ‚ÄúSkinning Mesh Animations‚Äù (SMA) approach!**
The SMA approach automatically extracts a skinned mesh from a given mesh animation. The main steps are:
- Triangle Segmentation: The triangles of the mesh are clustered into nearly rigid parts. This is done by analyzing the sequence of rotation transformations for each triangle throughout the animation and grouping triangles with similar rotation sequences. These clusters will become the rigid bones.
- Bone Transformation: For each frame and each identified bone (cluster), a rigid transformation (rotation and translation) is computed by averaging the transformations of all triangles belonging to that bone.
- Vertex Weight Estimation: A linear least squares problem is solved to find the optimal skinning weights for each vertex, determining how it should be influenced by the nearby bones.

9. **What are the feature vectors used for clustering the mesh triangles into bone clusters?**
- homogeneous transoformation matrix 3x3 or a 9D parameter vector 

10. **How are the vertex weights computed in the SMA approach?**
-  solving a constrained least squares problem.
- Bone Influence Selection: First, for each vertex, the b most influential bones are identified (where b is a small user-defined number). This is done greedily by finding the set of b bones that minimizes the animation reconstruction error for that vertex.
- Least Squares Fit: With the influencing bones known, a linear least squares problem is solved to find the optimal weights. This fit is often constrained (e.g., using non-negative least squares) to avoid overfitting and ensure plausible weights.

11. **Where is room for improvement in the SMA approach that was used in ‚ÄûFast&efficient skinning of animated meshes‚Äú?**
- The "Fast & Efficient Skinning of Animated Meshes" (F&ESAM) paper improves upon the general idea by addressing its computational complexity. The main improvement is solving the problem in a reduced trajectory space.
- Instead of working with the trajectories of all m vertices over k frames (a very large matrix A), the method first approximates the entire animation using a much smaller set of d basis trajectories (where d << m). The matrix decomposition problem is then solved in this much smaller, lower-dimensional space. This yields a slightly larger number of bones (d) than a full SVD would, but it can be solved in a significantly shorter amount of time.